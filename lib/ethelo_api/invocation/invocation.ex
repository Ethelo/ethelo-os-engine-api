defmodule EtheloApi.Invocation do
  @moduledoc """
  The boundary for communicating with the EtheloApi.

  All access to update database values go through this module.
  To keep code files small, the longer methods are in the /queries folder
  and are linked with defdelegate
  """
  alias EtheloApi.Invocation.ConfigJson
  alias EtheloApi.Invocation.DecisionJson
  alias EtheloApi.Invocation.InvocationFiles
  alias EtheloApi.Invocation.InvocationSettings
  alias EtheloApi.Invocation.MockEngine
  alias EtheloApi.Invocation.Queries.Cache
  alias EtheloApi.Invocation.Queue
  alias EtheloApi.Invocation.ScenarioHashes
  alias EtheloApi.Invocation.ScoringData
  alias EtheloApi.Invocation.SolveAttempt

  defdelegate queue_solve(decision, input), to: Queue
  defdelegate verify_solve_inputs(decision, input), to: Queue

  # allow mocking of engine module for tests
  def engine_module(), do: MockEngine

  @spec engine_solve({String.t(), String.t(), String.t(), String.t(), String.t() | nil}) ::
          {:ok | :error, String.t()}
  @doc """
  triggers a solve call on the engine.

  """
  def engine_solve(files) do
    engine_module().engine_solve(files)
  end

  @spec engine_preprocessed(String.t()) :: {:ok, String.t()} | {:error, String.t()}
  @doc """
  generates the a preprocessed file for the decision.
  This allows the engine to skip duplicate steps and solve faster.
  It accepts a Decision json file generated by build_decision_json/2
  """
  def engine_preprocessed(decision_json) do
    engine_module().engine_preprocessed(decision_json)
  end

  @doc """
  Passes solve settings data to engine
  """
  defdelegate solve(decision_id, scenario_config_id, option_list \\ []), to: SolveAttempt

  @doc """
  Helper method for quickly trigging a solve in console
  """
  def solve_group(decision_id, option_list \\ [])

  def solve_group(nil, _),
    do: raise(ArgumentError, message: "you must supply a Decision")

  def solve_group(decision_id, option_list) do
    scenario_config =
      EtheloApi.Structure.list_scenario_configs(decision_id, %{slug: "group"}) |> List.first()

    solve(scenario_config.decision_id, Map.get(scenario_config, :id, nil), option_list)
  end

  @doc """
  Helper method for quickly trigging a solve in console
  """
  def solve_participant(decision_id, participant_id, option_list \\ [])

  def solve_participant(nil, _, _),
    do: raise(ArgumentError, message: "you must supply a Decision")

  def solve_participant(decision_id, participant_id, option_list) do
    scenario_config =
      EtheloApi.Structure.list_scenario_configs(decision_id, %{slug: "participant"}) |> List.first()

    option_list =
      option_list
      |> Keyword.put(:participant_id, participant_id)

    solve(scenario_config.decision_id, scenario_config.id, option_list)
  end

  @doc """
  Generates json content that describes the structure of the Decision for the engine.
  """
  defdelegate build_decision_json(decision_id, pretty \\ false), to: DecisionJson, as: :build_json

  @doc """
  Generates json content that describes the solve configuration the engine should use.
  """
  defdelegate build_config_json(scenario_config, option_categories, pretty \\ false),
    to: ConfigJson,
    as: :build_json

  def decision_key(), do: "published_decision"

  def preprocessed_key(), do: "published_decision_preprocessed"

  def scenario_config_key(scenario_config_id),
    do: "published_scenario_config_#{scenario_config_id}"

  @doc """
  Update Decision json in the cache so it can be used in future solves.
  """
  defdelegate update_decision_cache(decision_id), to: Cache

  @doc """
  Update the ScenarioConfig file in the cache so it can be used in future solves.
  """
  defdelegate update_scenario_config_cache(scenario_config_id, decision_id), to: Cache

  def get_decision_cache_value(decision_id) do
    Cache.get_cache_value(decision_key(), decision_id)
  end

  def decision_cache_exists(decision_id) do
    Cache.cache_value_exists(decision_key(), decision_id)
  end

  @spec get_decision_preprocessed_cache_value(integer) :: String.t()
  def get_decision_preprocessed_cache_value(decision_id) do
    Cache.get_cache_value(preprocessed_key(), decision_id) || ""
  end

  def get_scenario_config_cache_value(scenario_config_id, decision_id) do
    Cache.get_cache_value(scenario_config_key(scenario_config_id), decision_id)
  end

  def scenario_config_cache_exists(scenario_config_id, decision_id) do
    Cache.cache_value_exists(scenario_config_key(scenario_config_id), decision_id)
  end

  def delete_decision_cache_value(decision_id) do
    Cache.delete_cache_value(decision_key(), decision_id)
  end

  def delete_decision_preprocessed_cache_value(decision_id) do
    Cache.delete_cache_value(preprocessed_key(), decision_id)
  end

  def delete_scenario_config_cache_value(scenario_config_id, decision_id) do
    Cache.delete_cache_value(scenario_config_key(scenario_config_id), decision_id)
  end

  defdelegate group_voting_data(
                decision_id,
                scenario_config_id \\ nil
              ),
              to: ScoringData,
              as: :initialize_all_voting

  defdelegate participant_voting_data(
                decision_id,
                participant_id,
                scenario_config_id \\ nil
              ),
              to: ScoringData,
              as: :initialize_single_voting

  defdelegate generate_scenario_config_hash(decision_id, scenario_config, use_cache),
    to: ScenarioHashes

  defdelegate generate_group_influent_hash(decision_id), to: ScenarioHashes
  defdelegate generate_participant_influent_hash(participant), to: ScenarioHashes

  def invocation_files(decision, options) do
    options = InvocationSettings.process_options(options)
    scenario_config_id = Keyword.get(options, :scenario_config_id)

    with(
      {:ok, settings} <- InvocationSettings.build(decision.id, scenario_config_id, options),
      {:ok, voting_data} <- SolveAttempt.voting_data(settings),
      {:ok, hash} <- SolveAttempt.get_hash(settings)
    ) do
      {:ok, files} = InvocationFiles.create(settings, voting_data)
      {:ok, Map.put(files, :hash, hash)}
    end
  end
end
